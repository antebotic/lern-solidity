//SPDX-License-Identifier: MIT
//Code from Signature Replay - Youtube: Smart Contract Programmer

pragma solidity ^0.6.0;

import "github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v3.3/contracts/cryptography/ECDSA.sol";

/*
  Signature Replay:
    - using the same signature to execute multiple identical signed transaction numerous time
    - in a multisig wallet, there are three ether, requiring two signatures to withdraw 1 ether at a time
    - #1 in order to reduce the number of transactions necessary from three (A signs, B signs, B withdraws)
      A can send a signed message to B offchain, B then signs it and requests withdraw. This is done in one
      transaction onchain. But, what is stopping B from using the message A signed multiple times.
    - #2 this is also applicable to the same code deployed on another adress (by A)
    - #3 and on a contract debployed by create2 (allways deploys on the same address) that has a selfdestruct
    
    Prevention:
    - #1 Having a unique signature for each transaction, implemented using nonce
    - #2 Including the address of the contract in the signature, also nonce logic
    - #3 It can't be done, nonce is reset on re-deploy and the contract address is allways the same
 */

 contract VulnerableMultiSigWallet {
  using ECDSA for bytes32;
  address[2] public owners;

  constructor(address[2] memory _owners) public payable {
    owners = _owners;
  }

  function deposit() external payable {}

  function transfer(address _to, uint _amount, bytes[2] memory sigs) external {
    bytes32 txHash = getTxHash(_to, _amount);
    (bool sent, ) = _to.call{value: _amount}("");
    require(sent, "Failed to send Ether");
  }

  function getTxHash(address _to, uint _amount) public view returns (bytes32) {
    return keccak256(abi.encodePacked(_to, _amount));
  }

  function _checkSigs(
    bytes[2] memory _sigs,
    bytes32 _txHash
  ) private view returns (bool) {
    bytes32 ethSignedHash = _txHash.toEthSignedMessageHash();

    for(uint i = 0; i < _sigs.length; i++) {
      address signer = ethSignedHash.recover(_sigs[i]);
      bool valid = signer == owners[i];

      if(!valid) { return false; }
    }

    return true;
  }
 }

//nonce and address added to txHash preventing a replay attack
 contract SecureMultiSigWallet {
  using ECDSA for bytes32;
  address[2] public owners;
  mapping(bytes32 => boolean) public executed;

  constructor(address[2] memory _owners) public payable {
    owners = _owners;
  }

  function deposit() external payable {}

  function transfer(address _to, uint _amount, uint _nonce, bytes[2] memory _sigs) external {
    bytes32 txHash = getTxHash(_to, _amount, _nonce);
    require(!executed[txHash], "tx allready executed");
    require(_checkSigs(_sigs, txHash), "invalid signature");
    executed[txHash] = true;

    (bool sent, ) = _to.call{value: _amount}("");
    require(sent, "Failed to send Ether");
  }

  function getTxHash(address _to, uint _amount, uint _nonce) public view returns (bytes32) {
    return keccak256(abi.encodePacked(address(this), _to, _amount, _nonce));
  }

  function _checkSigs(
    bytes[2] memory _sigs,
    bytes32 _txHash
  ) private view returns (bool) {
    bytes32 ethSignedHash = _txHash.toEthSignedMessageHash();

    for(uint i = 0; i < _sigs.length; i++) {
      address signer = ethSignedHash.recover(_sigs[i]);
      bool valid = signer == owners[i];

      if(!valid) { return false; }
    }

    return true;
  }
 }